---
### Apply recommanded run your app in production steps
#   https://docs.docker.com/get-started/orchestration/ , and all subsequent doc
# This documentation is massive, and some points are to be treated later, on services start

# To keep the cookbook concise, please refer to
# - /ansible/roles/docker-installation/templates/etc-docker-daemon-json.md    for detailed explanations
# - /ansible/roles/docker-installation/templates/etc-docker-daemon-json.j2    for the generated daemon.json file


## Orchestration > Deploy to Swarm
#   https://docs.docker.com/get-started/swarm-deploy/
# TODO: the_docker_guy will init the swarm

## Configure all objects
##  > Apply custom metadata to objects / Docker object labels
#   https://docs.docker.com/config/labels-custom-metadata/
# During containers/compose/service deployments

##  > Prune unused Docker objects
#   https://docs.docker.com/config/pruning/
# TODO: the_cron_guy will manage that

##  > Format command and log output
#   https://docs.docker.com/config/formatting/
# Will be managed by dedicated managers (Prometheus/Grafana)

##  Configure the Docker daemon
#   https://docs.docker.com/config/daemon/
# SSH used, no TLS

##  Collect Docker metrics with Prometheus
#   https://docs.docker.com/config/daemon/prometheus/
# Set up in monitoring, based on docker swarm rocks / https://dockerswarm.rocks/swarmprom/

##  Configure containers
##  > Start containers automatically
# Restart policy managed via ansible

##  > Keep containers alive during daemon downtime
#   https://docs.docker.com/config/containers/live-restore/
# Enable live restore via docker's daemon.json

##  > Run multiple services in a container
#   https://docs.docker.com/config/containers/multi-service_container/
# No

##  > Runtime metrics
#   https://docs.docker.com/config/containers/runmetrics/
# No > Grafana

##  > Runtime options with Memory, CPUs, and GPUs
#   https://docs.docker.com/config/containers/resource_constraints/

## Enable swap limit support if needed
# Cookbook default : not enabled > No need to enable if using only services
#   https://docs.docker.com/config/containers/resource_constraints/#understand-the-risks-of-running-out-of-memory
#   > Consider converting your container to a service, and using service-level constraints
#   > and node labels to ensure that the application runs only on hosts with enough memory

# /!\ Attention /!\
#   Memory and swap accounting incur an overhead of about 1% of the total available memory
#   and a 10% overall performance degradation, even if Docker is not running.

# Ansible can manage it
#   https://docs.ansible.com/ansible/latest/modules/docker_swarm_service_module.html#parameter-reservations

- name: 'Enable swap limit support ? {{ enableDockerSwapLimitSupport }}'
  debug:
    msg: "By default, in this cookbook, swap limit support (managing Memory, CPUs, GPUs) isn't enabled, as it's not mandatory if you exclusively uses services."

# Mandatory, else subsequent when: tests fails
- name: Get info on docker host
  docker_host_info:
    api_version: auto
  register: result

- name: Do we need to enable swap limit support ?
  debug:
    msg: '\nDocker host warnings:\n\n{{ result.host_info.Warnings }}\n\n'
  # If there is no warning, the property Warnings doesn't exist, and cookbook fails
  # when: "'WARNING: No swap limit support' in result.host_info.Warnings"
  when:
  - enableDockerSwapLimitSupport|default(false)|bool == true
  - "'WARNING: No swap limit support' in result.host_info"

# https://docs.docker.com/install/linux/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities
- name: Add swap limit support in GRUB config
  lineinfile:
    line: 'GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"'
    path: /etc/default/grub
    regexp: '^GRUB_CMDLINE_LINUX='
  when:
  - enableDockerSwapLimitSupport|default(false)|bool == true
  - "'WARNING: No swap limit support' in result.host_info"

- name: Update GRUB
  command: 'update-grub'
  when:
  - "'WARNING: No swap limit support' in result.host_info"
  - enableDockerSwapLimitSupport|default(false)|bool == true

# The changes take effect when the system is rebooted
- name: Reboot the Ubuntu server, for GRUB changes to take effect
  reboot:
    msg: 'Reboot initiated by Ansible due to kernel updates'
    connect_timeout: 5
    reboot_timeout: 300
    pre_reboot_delay: 0
    post_reboot_delay: 5
    test_command: uptime
  when:
  - enableDockerSwapLimitSupport|default(false)|bool == true
  - "'WARNING: No swap limit support' in result.host_info"

# Validation
- name: Get info on docker host
  docker_host_info:
    api_version: auto
  register: new_result
  when:
  - enableDockerSwapLimitSupport|default(false)|bool == true
  - "'WARNING: No swap limit support' in result.host_info"

- name: Validation
  debug:
    msg: 'Docker SwapLimit : {{ new_result.host_info.SwapLimit }}'
  when:
  - enableDockerSwapLimitSupport|default(false)|bool == true
  - "'WARNING: No swap limit support' in result.host_info"

# # # Remove swap limit support, if you enabled it by mistake
# # - name: Remove limit support in GRUB config
# #   lineinfile:
# #     line: 'GRUB_CMDLINE_LINUX=""'
# #     path: /etc/default/grub
# #     regexp: '^GRUB_CMDLINE_LINUX='

# # - name: Update GRUB
# #   command: 'update-grub'

# # # The changes take effect when the system is rebooted
# # - name: Reboot the Ubuntu server, for GRUB changes to take effect
# #   reboot:
# #     msg: 'Reboot initiated by Ansible due to kernel updates'
# #     connect_timeout: 5
# #     reboot_timeout: 300
# #     pre_reboot_delay: 0
# #     post_reboot_delay: 5
# #     test_command: uptime

# Anyway, it will be managed during services definition & fine tuned via Grafana


## Logging
# Already done

###  Security
##  > Kernel namespaces
# ok..

##  > Control groups
# ok...

##  > Docker daemon attack surface
# Dedicated user > the_docker_guy
#   OK / Can only connect through SSH, can't sudo
#   Should not be able to access host's parents folder, especially '/'
#     TODO: Currently it can `> cd /`
#   ? Restrict docker use to the_docker_guy
#   ? Restrict possibility to create a container from inside a container
#   Use traditional UNIX permission checks to limit access to the control socket
#   Limit docker functions
#   - docker load
#   - docker pull
#   Try to run exclusivly Docker on the server, except for SSH & monitoring. Other stuff as docker service

##  > Linux kernel capabilities
#       Capability list / https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities
#   Processes (like web servers) that just need to bind on a port below 1024 do not need to run as root:
#     they can just be granted the net_bind_service capability instead
#   > Drop all and restore 1 / https://opensource.com/business/15/3/docker-security-tuning
#   De manière générale, à l'intérieur du conteneur, pas droits pour ssh, cron, logs, hardware, network
#   ! The best practice for users would be to remove all capabilities except those explicitly required for their processes.
#     Création de profiles dédiés pour chaque image

##  > Docker Content Trust Signature Verification
# Force use of explicitly authorized images only, through a dockerhub account
# can be configured in daemon.json

##  > Other kernel security features
# Kernel securoty with GRSEC and PAX
# security model templates for Docker > Apparmor or SELinux
# User Namespaces are supported directly by the docker daemon. This feature allows for the root user in a container
#   to be mapped to a non uid-0 user outside the container, which can help to mitigate the risks of container breakout.
#   This facility is available but not enabled by default.

##  > Docker security non-events
# ok..

##  > Protect the Docker daemon socket
# Won't access fron the outside

##  > Verify repository client with certificates
# Add HTTPS between our docker daemon (host) and the official Docker registry (https://hub.docker.com/ ?)
#   Add the stuff with the_builder_guy and remove the_docker_guy rights to do the same
...